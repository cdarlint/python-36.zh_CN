# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 15:01+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: 张俊（fighting） <zj651927693@gmail.com>, 2017\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/arg.rst:6
msgid "Parsing arguments and building values"
msgstr "语句解释及变量编译"

#: ../../c-api/arg.rst:8
msgid ""
"These functions are useful when creating your own extensions functions and "
"methods.  Additional information and examples are available in :ref"
":`extending-index`."
msgstr "这些函数在创建你自己的函数时帮助很大。更多说明以及实例可参考说明文档中的 :ref:`extending-index` 小节。"

#: ../../c-api/arg.rst:12
msgid ""
"The first three of these functions described, :c:func:`PyArg_ParseTuple`, "
":c:func:`PyArg_ParseTupleAndKeywords`, and :c:func:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""
"这些函数描述的前三个，:c:func:`PyArg_ParseTuple`，:c:func:`PyArg_ParseTupleAndKeywords`，以及"
" :c:func:`PyArg_Parse`，它们都使用 *格式化字符串* 来将函数期待的参数告知函数。这些函数都使用相同语法规则的格式化字符串。"

#: ../../c-api/arg.rst:19
msgid "Parsing arguments"
msgstr "解析参数"

#: ../../c-api/arg.rst:21
msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"一个格式化字符串包含0或者更多的格式单元。一个格式单元用来描述一个Python对象；它通常是一个字符或者由括号括起来的格式单元序列。除了少数例外，一个非括号序列的格式单元通常对应这些函数的具有单一地址的参数。在接下来的描述中，双引号内的表达式是格式单元；圆括号()内的是对应这个格式单元的Python对象类型；方括号[]内的是传递的C变量(变量集)类型。"

#: ../../c-api/arg.rst:31
msgid "Strings and buffers"
msgstr "字符串和缓存区"

#: ../../c-api/arg.rst:33
msgid ""
"These formats allow accessing an object as a contiguous chunk of memory. You"
" don't have to provide raw storage for the returned unicode or bytes area."
msgstr "这些格式允许将对象按照连续的内存块形式进行访问。你没必要提供返回的unicode字符或者字节区的原始数据存储。"

#: ../../c-api/arg.rst:37
msgid ""
"In general, when a format sets a pointer to a buffer, the buffer is managed "
"by the corresponding Python object, and the buffer shares the lifetime of "
"this object.  You won't have to release any memory yourself. The only "
"exceptions are ``es``, ``es#``, ``et`` and ``et#``."
msgstr ""
"一般的，当一个表达式设置一个指针指向一个缓冲区，这个缓冲区可以被相应的Python对象管理，并且这个缓冲区共享这个对象的生存周期。你不需要人为的释放任何内存空间。除了这些"
" ``es``, ``es#``, ``et`` and ``et#``."

#: ../../c-api/arg.rst:42
msgid ""
"However, when a :c:type:`Py_buffer` structure gets filled, the underlying "
"buffer is locked so that the caller can subsequently use the buffer even "
"inside a :c:type:`Py_BEGIN_ALLOW_THREADS` block without the risk of mutable "
"data being resized or destroyed.  As a result, **you have to call** "
":c:func:`PyBuffer_Release` after you have finished processing the data (or "
"in any early abort case)."
msgstr ""
"然而，当一个 :c:type:`Py_buffer` 结构被赋值，其包含的缓冲区被锁住，所以调用者在随后使用这个缓冲区，即使在 "
":c:type:`Py_BEGIN_ALLOW_THREADS` 块中，可以避免可变数据因为调整大小或者被销毁所带来的风险。因此，**你不得不调用** "
":c:func:`PyBuffer_Release` 在你结束数据的处理时(或者在之前任何中断事件中)"

#: ../../c-api/arg.rst:49
msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "除非另有说明，缓冲区是不会以空终止的。"

#: ../../c-api/arg.rst:51
msgid ""
"Some formats require a read-only :term:`bytes-like object`, and set a "
"pointer instead of a buffer structure.  They work by checking that the "
"object's :c:member:`PyBufferProcs.bf_releasebuffer` field is *NULL*, which "
"disallows mutable objects such as :class:`bytearray`."
msgstr ""
"有些格式要求一个只读的 :term:`bytes-like object`，并且设置一个指针以取代一个缓存区结构。它们通过检查对象的 "
":c:member:`PyBufferProcs.bf_releasebuffer` 字段是 *NULL* 来工作，它们不允许诸如 "
":class:`bytearray` 这种可变的对象。"

#: ../../c-api/arg.rst:58
msgid ""
"For all ``#`` variants of formats (``s#``, ``y#``, etc.), the type of the "
"length argument (int or :c:type:`Py_ssize_t`) is controlled by defining the "
"macro :c:macro:`PY_SSIZE_T_CLEAN` before including :file:`Python.h`.  If the"
" macro was defined, length is a :c:type:`Py_ssize_t` rather than an "
":c:type:`int`. This behavior will change in a future Python version to only "
"support :c:type:`Py_ssize_t` and drop :c:type:`int` support. It is best to "
"always define :c:macro:`PY_SSIZE_T_CLEAN`."
msgstr ""
"所有 ``#`` 表达式的变式(``s#``，``y#``，等等)，长度参数的类型(整型或者 :c:type:`Py_ssize_t`)在包含 "
":file:`Python.h` 头文件之前由 :c:macro:`PY_SSIZE_T_CLEAN` 宏的定义控制。如果这个宏被定义，长度是一个 "
":c:type:`Py_ssize_t` Python元大小类型而不是一个 :c:type:`int` 整型。在未来的Python版本中将会改变，只支持"
" :c:type:`Py_ssize_t` 而放弃支持 :c:type:`int` 整型。最好一直定义 "
":c:macro:`PY_SSIZE_T_CLEAN` 这个宏。"

#: ../../c-api/arg.rst:85
msgid "``s`` (:class:`str`) [const char \\*]"
msgstr "``s`` (:class:`str`) [const char \\*]"

#: ../../c-api/arg.rst:68
msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address"
" you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded null code points; if it does, a :exc:`ValueError` exception"
" is raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""
"将一个Unicode对象转换成一个指向字符串的C指针。一个指针指向一个已经存在的字符串，这个字符串存储的是传如的字符指针变量。C字符串是已空结束的。Python字符串不能包含嵌入的无效的代码点；如果由，一个"
" :exc:`ValueError` 异常会被引发。Unicode对象被转化成 ``'utf-8'`` 编码的C字符串。如果转换失败，一个 "
":exc:`UnicodeError` 异常被引发。"

#: ../../c-api/arg.rst:77
msgid ""
"This format does not accept :term:`bytes-like objects <bytes-like object>`."
"  If you want to accept filesystem paths and convert them to C character "
"strings, it is preferable to use the ``O&`` format with "
":c:func:`PyUnicode_FSConverter` as *converter*."
msgstr ""
"这个表达式不接受 :term:`bytes-like objects <bytes-like "
"object>`。如果你想接受文件系统路径并将它们转化成C字符串，建议使用 ``O&`` 表达式配合 "
":c:func:`PyUnicode_FSConverter` 作为 *转化函数*。"

#: ../../c-api/arg.rst:83 ../../c-api/arg.rst:150
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null code points were "
"encountered in the Python string."
msgstr "以前，当Python字符串中遇到了嵌入的null代码点会引发 :exc:`TypeError` 。"

#: ../../c-api/arg.rst:91
msgid "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"
msgstr "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:88
msgid ""
"This format accepts Unicode objects as well as bytes-like objects. It fills "
"a :c:type:`Py_buffer` structure provided by the caller. In this case the "
"resulting C string may contain embedded NUL bytes. Unicode objects are "
"converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"这个表达式既接受Unicode对象也接受类字节类型对象。它为由调用者提供的 :c:type:`Py_buffer` "
"结构赋值。这里结果的C字符串可能包含嵌入的NUL字节。Unicode对象通过 ``'utf-8'`` 编码转化成C字符串。"

#: ../../c-api/arg.rst:98
msgid ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, "
"int or :c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str`, 只读 :term:`bytes-like object`) [const char \\*, int or "
":c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:94
msgid ""
"Like ``s*``, except that it doesn't accept mutable objects. The result is "
"stored into two C variables, the first one a pointer to a C string, the "
"second one its length. The string may contain embedded null bytes. Unicode "
"objects are converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"像 ``s*``，除了它不接受易变的对象。结果存储在两个C "
"变量中，第一个是指向C字符串的指针，第二个是它的长度。字符串可能包含嵌入的null字节。Unicode对象都被通过 ``'utf-8'`` "
"编码转化成C字符串。"

#: ../../c-api/arg.rst:102
msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``z`` (:class:`str` or ``None``) [const char \\*]"

#: ../../c-api/arg.rst:101
msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to *NULL*."
msgstr "像 ``s``，但是这个Python对象也有可能是 ``None``，那么对应的C指针指向 *NULL*。"

#: ../../c-api/arg.rst:106
msgid ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"
msgstr ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"

#: ../../c-api/arg.rst:105
msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :c:type:`Py_buffer` structure is set to *NULL*."
msgstr ""
"像 ``s*``，但是这个Python对象也有可能是 ``None``，那么对应的 :c:type:`Py_buffer` 结构中的 ``buf`` "
"指向 *NULL*。"

#: ../../c-api/arg.rst:110
msgid ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, int]"
msgstr ""
"``z#`` (:class:`str`, 只读 :term:`bytes-like object` or ``None``) [const char "
"\\*, int]"

#: ../../c-api/arg.rst:109
msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C"
" pointer is set to *NULL*."
msgstr "像 ``s#``，但是这个Python对象也有可能是 ``None``，那么对应的C指针指向 *NULL*。"

#: ../../c-api/arg.rst:120
msgid "``y`` (read-only :term:`bytes-like object`) [const char \\*]"
msgstr "``y`` (read-only :term:`bytes-like object`) [const char \\*]"

#: ../../c-api/arg.rst:113
msgid ""
"This format converts a bytes-like object to a C pointer to a character "
"string; it does not accept Unicode objects.  The bytes buffer must not "
"contain embedded null bytes; if it does, a :exc:`ValueError` exception is "
"raised."
msgstr ""
"这个表达式将一个类字节类型对象转化成一个指向字符串的C指针；它不接受Unicode对象。字节缓存区必须不包含嵌入的null字节；如果包含了null字节，会引发一个"
" :exc:`ValueError` 异常。"

#: ../../c-api/arg.rst:118
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes buffer."
msgstr "以前，当字节缓冲区中遇到了嵌入的null字节会引发 :exc:`TypeError` 。"

#: ../../c-api/arg.rst:125
msgid "``y*`` (:term:`bytes-like object`) [Py_buffer]"
msgstr "``y*`` (:term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:123
msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only bytes-like "
"objects.  **This is the recommended way to accept binary data.**"
msgstr "``s*`` 的变式，不接受Unicode对象，只接受类字节类型变量。**这是接受二进制数据的推荐方法**。"

#: ../../c-api/arg.rst:129
msgid "``y#`` (read-only :term:`bytes-like object`) [const char \\*, int]"
msgstr "``y#`` (read-only :term:`bytes-like object`) [const char \\*, int]"

#: ../../c-api/arg.rst:128
msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr " ``s#`` 的变式，不接受Unicode对象，只接受类字节类型变量。"

#: ../../c-api/arg.rst:134
msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr "``S`` (:class:`bytes`) [PyBytesObject \\*]"

#: ../../c-api/arg.rst:132
msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :c:type:`PyObject\\*`."
msgstr ""
"要求Python对象是一个 :class:`bytes` 类型对象，没有尝试任何的转换。如果不是一个字节类型对象会引发 :exc:`TypeError`"
" 异常。C变量也可能声明为 :c:type:`PyObject\\*` 类型。"

#: ../../c-api/arg.rst:139
msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"

#: ../../c-api/arg.rst:137
msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
":class:`bytearray` object. The C variable may also be declared as "
":c:type:`PyObject\\*`."
msgstr ""
"要求Python对象是一个 :class:`bytearray` 类型对象，没有尝试任何的转换。如果不是一个 :class:`bytearray` "
"类型对象会引发 :exc:`TypeError` 异常。C变量也可能声明为 :c:type:`PyObject\\*` 类型。"

#: ../../c-api/arg.rst:152 ../../c-api/arg.rst:557
msgid "``u`` (:class:`str`) [Py_UNICODE \\*]"
msgstr "``u`` (:class:`str`) [Py_UNICODE \\*]"

#: ../../c-api/arg.rst:142
msgid ""
"Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of"
" Unicode characters.  You must pass the address of a :c:type:`Py_UNICODE` "
"pointer variable, which will be filled with the pointer to an existing "
"Unicode buffer.  Please note that the width of a :c:type:`Py_UNICODE` "
"character depends on compilation options (it is either 16 or 32 bits). The "
"Python string must not contain embedded null code points; if it does, a "
":exc:`ValueError` exception is raised."
msgstr ""
"将一个Python Unicode对象转化成指向一个以空终止的Unicode字符缓冲区的指针。你必须传入一个 :c:type:`Py_UNICODE` "
"指针变量的地址，存储了一个指向已经存在的Unicode缓冲区的指针。请注意一个 :c:type:`Py_UNICODE` "
"类型的字符宽度取决于编译选项(16位或者32位)。Python字符串必须不能包含嵌入的null代码点；如果有，引发一个 "
":exc:`ValueError` 异常。"

#: ../../c-api/arg.rst:157 ../../c-api/arg.rst:562
msgid "``u#`` (:class:`str`) [Py_UNICODE \\*, int]"
msgstr "``u#`` (:class:`str`) [Py_UNICODE \\*, int]"

#: ../../c-api/arg.rst:155
msgid ""
"This variant on ``u`` stores into two C variables, the first one a pointer "
"to a Unicode data buffer, the second one its length.  This variant allows "
"null code points."
msgstr "``u`` 的变式，存储两个C变量，第一个指针指向一个Unicode数据缓存区，第二个是它的长度。它允许null代码点。"

#: ../../c-api/arg.rst:161
msgid "``Z`` (:class:`str` or ``None``) [Py_UNICODE \\*]"
msgstr "``Z`` (:class:`str` or ``None``) [Py_UNICODE \\*]"

#: ../../c-api/arg.rst:160
msgid ""
"Like ``u``, but the Python object may also be ``None``, in which case the "
":c:type:`Py_UNICODE` pointer is set to *NULL*."
msgstr ""
"像 ``u``，但是这个Python对象也有可能是 ``None``，那么对应的 :c:type:`Py_UNICODE` 指针指向 *NULL*。"

#: ../../c-api/arg.rst:165
msgid "``Z#`` (:class:`str` or ``None``) [Py_UNICODE \\*, int]"
msgstr "``Z#`` (:class:`str` or ``None``) [Py_UNICODE \\*, int]"

#: ../../c-api/arg.rst:164
msgid ""
"Like ``u#``, but the Python object may also be ``None``, in which case the "
":c:type:`Py_UNICODE` pointer is set to *NULL*."
msgstr ""
"像 ``u#``，但是这个Python对象也有可能是 ``None``，那么对应的 :c:type:`Py_UNICODE` 指针指向 *NULL*。"

#: ../../c-api/arg.rst:170
msgid "``U`` (:class:`str`) [PyObject \\*]"
msgstr "``U`` (:class:`str`) [PyObject \\*]"

#: ../../c-api/arg.rst:168
msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object."
"  The C variable may also be declared as :c:type:`PyObject\\*`."
msgstr ""
"要求Python对象是一个Unicode对象，没有尝试任何的转换。如果不是一个Unicode对象会引发 :exc:`TypeError` "
"异常。C变量也可能声明为 :c:type:`PyObject\\*` 类型。"

#: ../../c-api/arg.rst:176
msgid "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"
msgstr "``w*`` (可读写 :term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:173
msgid ""
"This format accepts any object which implements the read-write buffer "
"interface. It fills a :c:type:`Py_buffer` structure provided by the caller. "
"The buffer may contain embedded null bytes. The caller have to call "
":c:func:`PyBuffer_Release` when it is done with the buffer."
msgstr ""
"这个表达式接受任何实现可读写缓存区接口的对象。它为调用者提供的 :c:type:`Py_buffer` "
"结构赋值。缓冲区可能存在嵌入的null字节。当缓冲区使用完后调用者需要调用 :c:func:`PyBuffer_Release`。"

#: ../../c-api/arg.rst:193
msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:179
msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr "``s`` 的变式，它将编码后的Unicode字符存入字符缓冲区。它只处理没有嵌入NUL字节的已编码数据"

#: ../../c-api/arg.rst:182
msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :c:type:`const char\\*` which points to the name of an encoding as"
" a NUL-terminated string, or *NULL*, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :c:type:`char\\*\\*`; the value of the pointer"
" it references will be set to a buffer with the contents of the argument "
"text. The text will be encoded in the encoding specified by the first "
"argument."
msgstr ""
"这个表达式需要两个参数。第一个仅用于传入，并且必须是一个 :c:type:`const char\\*` 指向一个 ``'utf-8'`` "
"编码的以空终止或者 *NULL* 的字符串名称。如果Python不识别名字的编码方式会引发一个异常。第二个参数必须是一个 "
":c:type:`char\\*\\*`；指针指向一个包含了参数文本内容的缓存区。文本将被第一个参数指定的编码格式编码。"

#: ../../c-api/arg.rst:190
msgid ""
":c:func:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling "
":c:func:`PyMem_Free` to free the allocated buffer after use."
msgstr ""
":c:func:`PyArg_ParseTuple` 会分配一个足够大小的缓冲区，将编码后的数据拷贝进这个缓冲区并且设置 *\\*buffer* "
"引用这个新分配的内存空间。调用者有责任在使用后调用 :c:func:`PyMem_Free` 去释放已经分配的缓冲区。"

#: ../../c-api/arg.rst:198
msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:196
msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr "和 ``es`` 相同，除了不用重编码传入的字符串对象。相反，它假设传入的参数是编码后的字符串类型。"

#: ../../c-api/arg.rst:229
msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, int "
"\\*buffer_length]"
msgstr ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, int "
"\\*buffer_length]"

#: ../../c-api/arg.rst:201
msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer."
" Unlike the ``es`` format, this variant allows input data which contains NUL"
" characters."
msgstr "``s#`` 的变式，它将已编码的Unicode字符存入字符缓冲区。不像 ``es`` 表达式，它允许传入的数据包含NUL字符。"

#: ../../c-api/arg.rst:205
msgid ""
"It requires three arguments.  The first is only used as input, and must be a"
" :c:type:`const char\\*` which points to the name of an encoding as a NUL-"
"terminated string, or *NULL*, in which case ``'utf-8'`` encoding is used. An"
" exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :c:type:`char\\*\\*`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""
"它需要三个参数。第一个仅用于传入，并且必须是一个 :c:type:`const char\\*` 指向一个 ``'utf-8'`` 编码的以空终止或者 "
"*NULL* 的字符串名称。如果Python不识别名字的编码方式会引发一个异常。第二个参数必须是一个 "
":c:type:`char\\*\\*`；指针指向一个包含了参数文本内容的缓存区。文本将被第一个参数指定的编码格式编码。第三个参数必须是一个整型指针；指针引用的值用来设定输出缓冲区的字节数量。"

#: ../../c-api/arg.rst:215
msgid "There are two modes of operation:"
msgstr "有两种操作方式："

#: ../../c-api/arg.rst:217
msgid ""
"If *\\*buffer* points a *NULL* pointer, the function will allocate a buffer "
"of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :c:func:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""
"如果 *\\*buffer* 指向 *NULL*，这个函数会分配一个足够大小的缓冲区，将编码后的数据拷贝进这个缓冲区并且设置 *\\*buffer* "
"引用这个新分配的内存空间。调用者有责任在使用后调用 :c:func:`PyMem_Free` 去释放已经分配的缓冲区。"

#: ../../c-api/arg.rst:222
msgid ""
"If *\\*buffer* points to a non-*NULL* pointer (an already allocated buffer),"
" :c:func:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""

#: ../../c-api/arg.rst:228
msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr "在这两个例子中，*\\*buffer_length* 被设置为编码后结尾不为NUL的数据的长度。"

#: ../../c-api/arg.rst:234
msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, int \\*buffer_length]"
msgstr ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, int \\*buffer_length]"

#: ../../c-api/arg.rst:232
msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr "和 ``es#`` 相同，除了不用重编码传入的字符串对象。相反，它假设传入的参数是编码后的字符串类型。"

#: ../../c-api/arg.rst:237
msgid "Numbers"
msgstr "数字"

#: ../../c-api/arg.rst:241
msgid "``b`` (:class:`int`) [unsigned char]"
msgstr "``b`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:240
msgid ""
"Convert a nonnegative Python integer to an unsigned tiny int, stored in a C "
":c:type:`unsigned char`."
msgstr "将一个非负的Python整型转化成一个无符号的微整型，存储在一个C :c:type:`unsigned char` 类型中。"

#: ../../c-api/arg.rst:245 ../../c-api/arg.rst:583
msgid "``B`` (:class:`int`) [unsigned char]"
msgstr "``B`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:244
msgid ""
"Convert a Python integer to a tiny int without overflow checking, stored in "
"a C :c:type:`unsigned char`."
msgstr "将一个Python整型转化成一个微整型并不检查溢出问题，存储在一个C :c:type:`unsigned char` 类型中。"

#: ../../c-api/arg.rst:248 ../../c-api/arg.rst:577
msgid "``h`` (:class:`int`) [short int]"
msgstr "``h`` (:class:`int`) [short int]"

#: ../../c-api/arg.rst:248
msgid "Convert a Python integer to a C :c:type:`short int`."
msgstr "将一个Python整型转化成一个C :c:type:`short int` 短整型。"

#: ../../c-api/arg.rst:252 ../../c-api/arg.rst:586
msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr "``H`` (:class:`int`) [unsigned short int]"

#: ../../c-api/arg.rst:251
msgid ""
"Convert a Python integer to a C :c:type:`unsigned short int`, without "
"overflow checking."
msgstr "将一个Python整型转化成一个C :c:type:`unsigned short int` 无符号短整型，并不检查溢出问题。"

#: ../../c-api/arg.rst:255 ../../c-api/arg.rst:571
msgid "``i`` (:class:`int`) [int]"
msgstr "``i`` (:class:`int`) [int]"

#: ../../c-api/arg.rst:255
msgid "Convert a Python integer to a plain C :c:type:`int`."
msgstr "将一个Python整型转化成一个C :c:type:`int` 整型。"

#: ../../c-api/arg.rst:259 ../../c-api/arg.rst:589
msgid "``I`` (:class:`int`) [unsigned int]"
msgstr "``I`` (:class:`int`) [unsigned int]"

#: ../../c-api/arg.rst:258
msgid ""
"Convert a Python integer to a C :c:type:`unsigned int`, without overflow "
"checking."
msgstr "将一个Python整型转化成一个C :c:type:`unsigned int` 无符号整型，并不检查溢出问题。"

#: ../../c-api/arg.rst:262 ../../c-api/arg.rst:580
msgid "``l`` (:class:`int`) [long int]"
msgstr "``l`` (:class:`int`) [long int]"

#: ../../c-api/arg.rst:262
msgid "Convert a Python integer to a C :c:type:`long int`."
msgstr "将一个Python整型转化成一个C :c:type:`long int` 长整型。"

#: ../../c-api/arg.rst:266 ../../c-api/arg.rst:592
msgid "``k`` (:class:`int`) [unsigned long]"
msgstr "``k`` (:class:`int`) [unsigned long]"

#: ../../c-api/arg.rst:265
msgid ""
"Convert a Python integer to a C :c:type:`unsigned long` without overflow "
"checking."
msgstr "将一个Python整型转化成一个C :c:type:`unsigned long int` 无符号长整型，并不检查溢出问题。"

#: ../../c-api/arg.rst:269 ../../c-api/arg.rst:595
msgid "``L`` (:class:`int`) [long long]"
msgstr ""

#: ../../c-api/arg.rst:269
msgid "Convert a Python integer to a C :c:type:`long long`."
msgstr ""

#: ../../c-api/arg.rst:273 ../../c-api/arg.rst:598
msgid "``K`` (:class:`int`) [unsigned long long]"
msgstr ""

#: ../../c-api/arg.rst:272
msgid ""
"Convert a Python integer to a C :c:type:`unsigned long long` without "
"overflow checking."
msgstr ""

#: ../../c-api/arg.rst:276 ../../c-api/arg.rst:601
msgid "``n`` (:class:`int`) [Py_ssize_t]"
msgstr "``n`` (:class:`int`) [Py_ssize_t]"

#: ../../c-api/arg.rst:276
msgid "Convert a Python integer to a C :c:type:`Py_ssize_t`."
msgstr "将一个Python整型转化成一个C :c:type:`Py_ssize_t` Python元大小类型。"

#: ../../c-api/arg.rst:283
msgid "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"
msgstr "``c`` (:class:`bytes` 或者 :class:`bytearray` 长度为1) [char]"

#: ../../c-api/arg.rst:279
msgid ""
"Convert a Python byte, represented as a :class:`bytes` or :class:`bytearray`"
" object of length 1, to a C :c:type:`char`."
msgstr ""
"将一个Python字节类型，如一个长度为1的 :class:`bytes` 或者 :class:`bytearray` 对象，转化成一个C "
":c:type:`char` 字符类型。"

#: ../../c-api/arg.rst:282
msgid "Allow :class:`bytearray` objects."
msgstr "允许 :class:`bytearray` 类型的对象。"

#: ../../c-api/arg.rst:287 ../../c-api/arg.rst:609
msgid "``C`` (:class:`str` of length 1) [int]"
msgstr "``C`` (:class:`str` 长度为1) [int]"

#: ../../c-api/arg.rst:286
msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :c:type:`int`."
msgstr "将一个Python字符，如一个长度为1的 :class:`str` 字符串对象，转化成一个C :c:type:`int` 整型类型。"

#: ../../c-api/arg.rst:290 ../../c-api/arg.rst:615
msgid "``f`` (:class:`float`) [float]"
msgstr "``f`` (:class:`float`) [float]"

#: ../../c-api/arg.rst:290
msgid "Convert a Python floating point number to a C :c:type:`float`."
msgstr "将一个Python浮点数转化成一个C :c:type:`float` 浮点数。"

#: ../../c-api/arg.rst:293 ../../c-api/arg.rst:612
msgid "``d`` (:class:`float`) [double]"
msgstr "``d`` (:class:`float`) [double]"

#: ../../c-api/arg.rst:293
msgid "Convert a Python floating point number to a C :c:type:`double`."
msgstr "将一个Python浮点数转化成一个C :c:type:`double` 双精度浮点数。"

#: ../../c-api/arg.rst:296
msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr "``D`` (:class:`complex`) [Py_complex]"

#: ../../c-api/arg.rst:296
msgid "Convert a Python complex number to a C :c:type:`Py_complex` structure."
msgstr "将一个Python复数类型转化成一个C :c:type:`Py_complex` Python复数类型。"

#: ../../c-api/arg.rst:299
msgid "Other objects"
msgstr "其他对象"

#: ../../c-api/arg.rst:304 ../../c-api/arg.rst:626
msgid "``O`` (object) [PyObject \\*]"
msgstr "``O`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:302
msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C"
" program thus receives the actual object that was passed.  The object's "
"reference count is not increased.  The pointer stored is not *NULL*."
msgstr ""
"用一个C的对象指针存储一个Python对象(没有任何格式转换)。这样传递给C程序的是实际的对象。这个对象的引用计数不会增加。这个指针存储的不是 "
"*NULL*。"

#: ../../c-api/arg.rst:311
msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr "``O!`` (object) [*typeobject*, PyObject \\*]"

#: ../../c-api/arg.rst:307
msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the"
" second is the address of the C variable (of type :c:type:`PyObject\\*`) "
"into which the object pointer is stored.  If the Python object does not have"
" the required type, :exc:`TypeError` is raised."
msgstr ""
"将一个Python对象存入一个C指针。和 ``O`` 类似，但是需要两个C参数：第一个是Python类型对象的地址，第二个是存储对象指针的C变量( "
":c:type:`PyObject\\*` 变量)的地址。如果Python对象类型不对，会抛出 :exc:`TypeError` 异常。"

#: ../../c-api/arg.rst:336 ../../c-api/arg.rst:640
msgid "``O&`` (object) [*converter*, *anything*]"
msgstr "``O&`` (object) [*converter*, *anything*]"

#: ../../c-api/arg.rst:316
msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address"
" of a C variable (of arbitrary type), converted to :c:type:`void \\*`.  The "
"*converter* function in turn is called as follows::"
msgstr ""
"通过一个 *converter* "
"函数将一个Python对象转换成一个C变量。这需要两个参数：第一个是一个函数，第二个是一个C变量的地址(任意类型的)，转化为 :c:type:`void"
" \\*` 类型。*converter* 函数像这样被调用："

#: ../../c-api/arg.rst:323
msgid ""
"where *object* is the Python object to be converted and *address* is the "
":c:type:`void\\*` argument that was passed to the :c:func:`PyArg_Parse\\*` "
"function. The returned *status* should be ``1`` for a successful conversion "
"and ``0`` if the conversion has failed.  When the conversion fails, the "
"*converter* function should raise an exception and leave the content of "
"*address* unmodified."
msgstr ""
"*object*是待转化的Python对象并且 *address* 是传入 :c:func:`PyArg_Parse\\*` 函数的 "
":c:type:`void\\*` 类型参数。返回的 *status* "
"是1代表转换成功，0代表转换失败。当转换失败，*converter*函数会引发一个异常并且不会修改 *address* 的内容。"

#: ../../c-api/arg.rst:329
msgid ""
"If the *converter* returns ``Py_CLEANUP_SUPPORTED``, it may get called a "
"second time if the argument parsing eventually fails, giving the converter a"
" chance to release any memory that it had already allocated. In this second "
"call, the *object* parameter will be NULL; *address* will have the same "
"value as in the original call."
msgstr ""
"如果 *converter* 返回 "
"``Py_CLEANUP_SUPPORTED``，如果参数解析最后失败了它会被第二次调用，给转换函数一个机会区释放它已经分配的内存。在第二次调用中， "
"*object* 参数会是NULL； *address* 会保持第一次调用时的值。"

#: ../../c-api/arg.rst:335
msgid "``Py_CLEANUP_SUPPORTED`` was added."
msgstr "``Py_CLEANUP_SUPPORTED`` 被添加。"

#: ../../c-api/arg.rst:345
msgid "``p`` (:class:`bool`) [int]"
msgstr "``p`` (:class:`bool`) [int]"

#: ../../c-api/arg.rst:339
msgid ""
"Tests the value passed in for truth (a boolean **p**\\ redicate) and "
"converts the result to its equivalent C true/false integer value. Sets the "
"int to ``1`` if the expression was true and ``0`` if it was false. This "
"accepts any valid Python value.  See :ref:`truth` for more information about"
" how Python tests values for truth."
msgstr ""

#: ../../c-api/arg.rst:350 ../../c-api/arg.rst:643
msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr "``(items)`` (:class:`tuple`) [*matching-items*]"

#: ../../c-api/arg.rst:348
msgid ""
"The object must be a Python sequence whose length is the number of format "
"units in *items*.  The C arguments must correspond to the individual format "
"units in *items*.  Format units for sequences may be nested."
msgstr ""
"对象必须是Python序列，它的长度是 *items* 中格式单元的数量。C参数必须对应 *items* "
"中每一个独立的格式单元。序列中的格式单元可能有嵌套。"

#: ../../c-api/arg.rst:352
msgid ""
"It is possible to pass \"long\" integers (integers whose value exceeds the "
"platform's :const:`LONG_MAX`) however no proper range checking is done --- "
"the most significant bits are silently truncated when the receiving field is"
" too small to receive the value (actually, the semantics are inherited from "
"downcasts in C --- your mileage may vary)."
msgstr ""
"传递 “长”整型(整型的值超过了平台的 :const:`LONG_MAX` "
"限制)是可能的，然而没有进行适当的范围检测——当接收字段太小而接收不到值时，最重要的位被静默地截断(实际上，C语言会在语义继承的基础上强制类型转换——期望的值可能会发生变化)。"

#: ../../c-api/arg.rst:358
msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr "格式化字符串中还有一些其他的字符具有特殊的涵义。这些可能并不嵌套在圆括号中。它们是："

#: ../../c-api/arg.rst:366
msgid "``|``"
msgstr "``|``"

#: ../../c-api/arg.rst:362
msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :c:func:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""
"表明在Python参数列表中剩下的参数都是可选的。C变量对应的可选参数需要初始化为默认值——当一个可选参数没有指定时， "
":c:func:`PyArg_ParseTuple`  不能访问相应的C变量(变量集)的内容。"

#: ../../c-api/arg.rst:375
msgid "``$``"
msgstr "``$``"

#: ../../c-api/arg.rst:369
msgid ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Indicates that the remaining "
"arguments in the Python argument list are keyword-only.  Currently, all "
"keyword-only arguments must also be optional arguments, so ``|`` must always"
" be specified before ``$`` in the format string."
msgstr ""
":c:func:`PyArg_ParseTupleAndKeywords` "
"only：表明在Python参数列表中剩下的参数都是强制关键字参数。当前，所有强制关键字参数都必须也是可选参数，所以格式化字符串中  ``|`` "
"必须一直在 ``$`` 前面。"

#: ../../c-api/arg.rst:380
msgid "``:``"
msgstr "``:``"

#: ../../c-api/arg.rst:378
msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :c:func:`PyArg_ParseTuple` raises)."
msgstr ""
"格式单元的列表结束标志；冒号后的字符串被用来作为错误消息中的函数名(:c:func:`PyArg_ParseTuple` 函数引发的“关联值”异常)。"

#: ../../c-api/arg.rst:385
msgid "``;``"
msgstr "``;``"

#: ../../c-api/arg.rst:383
msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and "
"``;`` mutually exclude each other."
msgstr "格式单元的列表结束标志；分号后的字符串被用来作为错误消息取代默认的错误消息。 ``:`` 和 ``;`` 相互排斥。"

#: ../../c-api/arg.rst:387
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr "注意任何由调用者提供的Python对象引用是 *借来的* 引用；不要递减它们的引用计数！"

#: ../../c-api/arg.rst:390
msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""
"传递给这些函数的附加参数必须是由格式化字符串确定的变量的地址；这些都是用来存储输入元组的值。有一些情况，如上面的格式单元列表中所描述的，这些参数作为输入值使用；在这种情况下，它们应该匹配指定的相应的格式单元。"

#: ../../c-api/arg.rst:396
msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the :c:func:`PyArg_Parse\\*` "
"functions return true, otherwise they return false and raise an appropriate "
"exception. When the :c:func:`PyArg_Parse\\*` functions fail due to "
"conversion failure in one of the format units, the variables at the "
"addresses corresponding to that and the following format units are left "
"untouched."
msgstr ""
"为了转换成功，*arg* 对象必须匹配格式并且格式必须用尽。成功的话，:c:func:`PyArg_Parse\\*` "
"函数返回true，反之它们返回false并且引发一个合适的异常。当 :c:func:`PyArg_Parse\\*` "
"函数因为某一个格式单元转化失败而失败时，对应的以及后续的格式单元地址内的变量都不会被使用。"

#: ../../c-api/arg.rst:405
msgid "API Functions"
msgstr "API 函数"

#: ../../c-api/arg.rst:409
msgid ""
"Parse the parameters of a function that takes only positional parameters "
"into local variables.  Returns true on success; on failure, it returns false"
" and raises the appropriate exception."
msgstr "解析一个函数的参数，表达式中的参数按参数位置顺序存入局部变量中。成功返回true；失败返回false并且引发相应的异常。"

#: ../../c-api/arg.rst:416
msgid ""
"Identical to :c:func:`PyArg_ParseTuple`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr "和 :c:func:`PyArg_ParseTuple` 相同，然而它接受一个va_list类型的参数而不是可变数量的参数集。"

#: ../../c-api/arg.rst:422
msgid ""
"Parse the parameters of a function that takes both positional and keyword "
"parameters into local variables.  The *keywords* argument is a "
"*NULL*-terminated array of keyword parameter names.  Empty names denote :ref"
":`positional-only parameters <positional-only_parameter>`. Returns true on "
"success; on failure, it returns false and raises the appropriate exception."
msgstr ""

#: ../../c-api/arg.rst:429
msgid ""
"Added support for :ref:`positional-only parameters <positional-"
"only_parameter>`."
msgstr ""

#: ../../c-api/arg.rst:436
msgid ""
"Identical to :c:func:`PyArg_ParseTupleAndKeywords`, except that it accepts a"
" va_list rather than a variable number of arguments."
msgstr ""
"和 :c:func:`PyArg_ParseTupleAndKeywords` 相同，然而它接受一个va_list类型的参数而不是可变数量的参数集。"

#: ../../c-api/arg.rst:442
msgid ""
"Ensure that the keys in the keywords argument dictionary are strings.  This "
"is only needed if :c:func:`PyArg_ParseTupleAndKeywords` is not used, since "
"the latter already does this check."
msgstr ""
"确保字典中的关键字参数都是字符串。这个函数只被使用于 :c:func:`PyArg_ParseTupleAndKeywords` "
"不被使用的情况下，后者已经不再做这样的检查。"

#: ../../c-api/arg.rst:452
msgid ""
"Function used to deconstruct the argument lists of \"old-style\" functions "
"--- these are functions which use the :const:`METH_OLDARGS` parameter "
"parsing method, which has been removed in Python 3.  This is not recommended"
" for use in parameter parsing in new code, and most code in the standard "
"interpreter has been modified to no longer use this for that purpose.  It "
"does remain a convenient way to decompose other tuples, however, and may "
"continue to be used for that purpose."
msgstr ""
"函数被用来析构“旧类型”函数的参数列表——这些函数使用的 :const:`METH_OLDARGS` 参数解析方法已从Python "
"3中移除。这不被推荐用于新代码的参数解析，并且在标准解释器中的大多数代码已被修改，已不再用于该目的。它仍然方便于分解其他元组，然而可能因为这个目的被继续使用。"

#: ../../c-api/arg.rst:463
msgid ""
"A simpler form of parameter retrieval which does not use a format string to "
"specify the types of the arguments.  Functions which use this method to "
"retrieve their parameters should be declared as :const:`METH_VARARGS` in "
"function or method tables.  The tuple containing the actual parameters "
"should be passed as *args*; it must actually be a tuple.  The length of the "
"tuple must be at least *min* and no more than *max*; *min* and *max* may be "
"equal.  Additional arguments must be passed to the function, each of which "
"should be a pointer to a :c:type:`PyObject\\*` variable; these will be "
"filled in with the values from *args*; they will contain borrowed "
"references.  The variables which correspond to optional parameters not given"
" by *args* will not be filled in; these should be initialized by the caller."
" This function returns true on success and false if *args* is not a tuple or"
" contains the wrong number of elements; an exception will be set if there "
"was a failure."
msgstr ""
"一个不使用格式化字符串指定参数类型的简单形式的参数检索。使用这种方法来检索参数的函数应该在函数或者方法表中声明 "
":const:`METH_VARARGS`。包含实际参数的元组应该以 *args* 形式被传入；它必须是一个实际的元组。元组的长度必须至少是 *min*"
" 并且不超过 *max*； *min* 和 *max* 可能相同。额外的参数必须传递给函数，每一个参数必须是一个指向 "
":c:type:`PyObject\\*` 类型变量的指针；它们将被赋值为 *args* 的值；它们将包含借来的引用。不在 *args* "
"里面的可选参数不会被赋值；由调用者完成初始化。函数成功则返回true并且如果 *args* "
"不是元组或者包含错误数量的元素则返回false；如果失败了会引发一个异常。"

#: ../../c-api/arg.rst:477
msgid ""
"This is an example of the use of this function, taken from the sources for "
"the :mod:`_weakref` helper module for weak references::"
msgstr "这是一个使用此函数的示例，取自 :mod:`_weakref` 帮助模块用来弱化引用的源代码："

#: ../../c-api/arg.rst:493
msgid ""
"The call to :c:func:`PyArg_UnpackTuple` in this example is entirely "
"equivalent to this call to :c:func:`PyArg_ParseTuple`::"
msgstr ""
"这个例子中调用 :c:func:`PyArg_UnpackTuple` 完全等价于调用 :c:func:`PyArg_ParseTuple`::"

#: ../../c-api/arg.rst:501
msgid "Building values"
msgstr "创建变量"

#: ../../c-api/arg.rst:505
msgid ""
"Create a new value based on a format string similar to those accepted by the"
" :c:func:`PyArg_Parse\\*` family of functions and a sequence of values.  "
"Returns the value or *NULL* in the case of an error; an exception will be "
"raised if *NULL* is returned."
msgstr ""
"基于格式化字符串创建一个新的值和那些 :c:func:`PyArg_Parse\\*` 函数族接受的函数及一系列值类似。返回这个值或者一旦出错返回 "
"*NULL*；如果返回的是 *NULL* 会引发一个异常。"

#: ../../c-api/arg.rst:510
msgid ""
":c:func:`Py_BuildValue` does not always build a tuple.  It builds a tuple "
"only if its format string contains two or more format units.  If the format "
"string is empty, it returns ``None``; if it contains exactly one format "
"unit, it returns whatever object is described by that format unit.  To force"
" it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""
":c:func:`Py_BuildValue` "
"并不一直创建一个元组。只有当它的格式化字符串包含两个或更多的格式单元才会创建一个元组。如果格式化字符串是空，它返回 "
"``None``；如果它包含一个格式单元，它返回由格式单元描述的的任一对象。用圆括号包裹格式化字符串可以强制它返回一个大小为0或者1的元组"

#: ../../c-api/arg.rst:516
msgid ""
"When memory buffers are passed as parameters to supply data to build "
"objects, as for the ``s`` and ``s#`` formats, the required data is copied.  "
"Buffers provided by the caller are never referenced by the objects created "
"by :c:func:`Py_BuildValue`.  In other words, if your code invokes "
":c:func:`malloc` and passes the allocated memory to :c:func:`Py_BuildValue`,"
" your code is responsible for calling :c:func:`free` for that memory once "
":c:func:`Py_BuildValue` returns."
msgstr ""
"当内存缓存区的数据以参数形式传递用来构建对象时，如 ``s`` 和 ``s#`` 格式单元，会拷贝需要的数据。调用者提供的缓冲区从来都不会被由 "
":c:func:`Py_BuildValue` 创建的对象来引用。换句话说，如果你的代码调用 :c:func:`malloc` "
"并且将分配的内存空间传递给 :c:func:`Py_BuildValue`，你的代码就有责任在 :c:func:`Py_BuildValue` "
"返回时调用 :c:func:`free` 。"

#: ../../c-api/arg.rst:524
msgid ""
"In the following description, the quoted form is the format unit; the entry "
"in (round) parentheses is the Python object type that the format unit will "
"return; and the entry in [square] brackets is the type of the C value(s) to "
"be passed."
msgstr ""
"在下面的描述中，双引号的表达式使格式单元；圆括号()内的是格式单元将要返回的Python对象类型；方括号[]内的是传递的C变量(变量集)的类型"

#: ../../c-api/arg.rst:528
msgid ""
"The characters space, tab, colon and comma are ignored in format strings "
"(but not within format units such as ``s#``).  This can be used to make long"
" format strings a tad more readable."
msgstr ""
"字符例如空格，制表符，冒号和逗号在格式化字符串中会被忽略(但是不包括格式单元，如 ``s#``)。这可以使很长的格式化字符串具有更好的可读性。"

#: ../../c-api/arg.rst:534
msgid "``s`` (:class:`str` or ``None``) [char \\*]"
msgstr "``s#`` (:class:`str` 或者 ``None``) [char \\*, int]"

#: ../../c-api/arg.rst:533
msgid ""
"Convert a null-terminated C string to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is *NULL*, ``None`` is used."
msgstr ""
"使用 ``'utf-8'`` 编码将一个C以空结束的字符串转化成Python :class:`str` 字符串对象。如果这个C字符串指针是 *NULL*"
" ，返回 ``None`` 。"

#: ../../c-api/arg.rst:539
msgid "``s#`` (:class:`str` or ``None``) [char \\*, int]"
msgstr "``s#`` (:class:`str` 或者 ``None``) [char \\*, int]"

#: ../../c-api/arg.rst:537
msgid ""
"Convert a C string and its length to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is *NULL*, the length is "
"ignored and ``None`` is returned."
msgstr ""
"使用 ``'utf-8'`` 编码将一个C字符串和其长度转化成Python :class:`str` 字符串对象。如果这个C字符串指针是 *NULL* "
"，长度会被忽略并且返回 ``None`` 。"

#: ../../c-api/arg.rst:543
msgid "``y`` (:class:`bytes`) [char \\*]"
msgstr "``y`` (:class:`bytes`) [char \\*]"

#: ../../c-api/arg.rst:542
msgid ""
"This converts a C string to a Python :class:`bytes` object.  If the C string"
" pointer is *NULL*, ``None`` is returned."
msgstr ""
"它将一个C字符串和其长度转化成一个Python :class:`bytes` 字节类型对象。如果这个C字符串指针是 *NULL*，返回``None``"

#: ../../c-api/arg.rst:547
msgid "``y#`` (:class:`bytes`) [char \\*, int]"
msgstr "``y#`` (:class:`bytes`) [char \\*, int]"

#: ../../c-api/arg.rst:546
msgid ""
"This converts a C string and its lengths to a Python object.  If the C "
"string pointer is *NULL*, ``None`` is returned."
msgstr "它将一个C字符串和其长度转化成一个Python对象。如果这个C字符串指针是 *NULL*，返回``None``。"

#: ../../c-api/arg.rst:550
msgid "``z`` (:class:`str` or ``None``) [char \\*]"
msgstr "``z`` (:class:`str` 或者 ``None``) [char \\*]"

#: ../../c-api/arg.rst:550 ../../c-api/arg.rst:565
msgid "Same as ``s``."
msgstr "和``s``一样。"

#: ../../c-api/arg.rst:553
msgid "``z#`` (:class:`str` or ``None``) [char \\*, int]"
msgstr "``z#`` (:class:`str` 或者 ``None``) [char \\*, int]"

#: ../../c-api/arg.rst:553 ../../c-api/arg.rst:568
msgid "Same as ``s#``."
msgstr "和``s#``一样。"

#: ../../c-api/arg.rst:556
msgid ""
"Convert a null-terminated buffer of Unicode (UCS-2 or UCS-4) data to a "
"Python Unicode object.  If the Unicode buffer pointer is *NULL*, ``None`` is"
" returned."
msgstr ""
"将一个以空结束的Unicode(UCS-2或者UCS-4)数据缓存区转化成Python Unicode对象。如果这个Unicode缓存区指针是 "
"*NULL*，返回``None``"

#: ../../c-api/arg.rst:560
msgid ""
"Convert a Unicode (UCS-2 or UCS-4) data buffer and its length to a Python "
"Unicode object.   If the Unicode buffer pointer is *NULL*, the length is "
"ignored and ``None`` is returned."
msgstr ""
"将一个Unicode(UCS-2或者UCS-4)数据缓存区和它的长度转化成Python Unicode对象。如果这个Unicode缓存区指针是 "
"*NULL*，长度将被忽略并且返回``None``"

#: ../../c-api/arg.rst:565
msgid "``U`` (:class:`str` or ``None``) [char \\*]"
msgstr "``U`` (:class:`str` 或者 ``None``) [char \\*]"

#: ../../c-api/arg.rst:568
msgid "``U#`` (:class:`str` or ``None``) [char \\*, int]"
msgstr "``U#`` (:class:`str` 或者 ``None``) [char \\*, int]"

#: ../../c-api/arg.rst:571
msgid "Convert a plain C :c:type:`int` to a Python integer object."
msgstr "将一个C :c:type:`int` 整型转化成Python整型对象。"

#: ../../c-api/arg.rst:574
msgid "``b`` (:class:`int`) [char]"
msgstr "``b`` (:class:`int`) [char]"

#: ../../c-api/arg.rst:574
msgid "Convert a plain C :c:type:`char` to a Python integer object."
msgstr "将一个C :c:type:`char` 字符型转化成Python整型对象。"

#: ../../c-api/arg.rst:577
msgid "Convert a plain C :c:type:`short int` to a Python integer object."
msgstr "将一个C :c:type:`short int` 短整型转化成Python整型对象。"

#: ../../c-api/arg.rst:580
msgid "Convert a C :c:type:`long int` to a Python integer object."
msgstr "将一个C :c:type:`long int` 长整型转化成Python整型对象。"

#: ../../c-api/arg.rst:583
msgid "Convert a C :c:type:`unsigned char` to a Python integer object."
msgstr "将一个C :c:type:`unsigned char` 无符号字符型转化成Python整型对象。"

#: ../../c-api/arg.rst:586
msgid "Convert a C :c:type:`unsigned short int` to a Python integer object."
msgstr "将一个C :c:type:`unsigned long` 无符号短整型转化成Python整型对象。"

#: ../../c-api/arg.rst:589
msgid "Convert a C :c:type:`unsigned int` to a Python integer object."
msgstr "将一个C :c:type:`unsigned long` 无符号整型转化成Python整型对象。"

#: ../../c-api/arg.rst:592
msgid "Convert a C :c:type:`unsigned long` to a Python integer object."
msgstr "将一个C :c:type:`unsigned long` 无符号长整型转化成Python整型对象。"

#: ../../c-api/arg.rst:595
msgid "Convert a C :c:type:`long long` to a Python integer object."
msgstr ""

#: ../../c-api/arg.rst:598
msgid "Convert a C :c:type:`unsigned long long` to a Python integer object."
msgstr ""

#: ../../c-api/arg.rst:601
msgid "Convert a C :c:type:`Py_ssize_t` to a Python integer."
msgstr "将一个C :c:type:`Py_ssize_t` 类型转化为Python整型。"

#: ../../c-api/arg.rst:605
msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr "``c`` (:class:`bytes` 长度为1 ) [char]"

#: ../../c-api/arg.rst:604
msgid ""
"Convert a C :c:type:`int` representing a byte to a Python :class:`bytes` "
"object of length 1."
msgstr "将一个C :c:type:`int` 整型代表的字符转化为Python :class:`bytes` 长度为1的字节对象。"

#: ../../c-api/arg.rst:608
msgid ""
"Convert a C :c:type:`int` representing a character to Python :class:`str` "
"object of length 1."
msgstr "将一个C :c:type:`int` 整型代表的字符转化为Python :class:`str` 长度为1的字符串对象。"

#: ../../c-api/arg.rst:612
msgid "Convert a C :c:type:`double` to a Python floating point number."
msgstr "将一个C :c:type:`double` 双精度浮点数转化为Python浮点数类型数字。"

#: ../../c-api/arg.rst:615
msgid "Convert a C :c:type:`float` to a Python floating point number."
msgstr "将一个C :c:type:`float` 单精度浮点数转化为Python浮点数类型数字。"

#: ../../c-api/arg.rst:618
msgid "``D`` (:class:`complex`) [Py_complex \\*]"
msgstr "``D`` (:class:`复数`) [Py_complex \\*]"

#: ../../c-api/arg.rst:618
msgid "Convert a C :c:type:`Py_complex` structure to a Python complex number."
msgstr "将一个C :c:type:`Py_complex` 类型的结构转化为Python复数类型。"

#: ../../c-api/arg.rst:621
msgid ""
"Pass a Python object untouched (except for its reference count, which is "
"incremented by one).  If the object passed in is a *NULL* pointer, it is "
"assumed that this was caused because the call producing the argument found "
"an error and set an exception. Therefore, :c:func:`Py_BuildValue` will "
"return *NULL* but won't raise an exception.  If no exception has been raised"
" yet, :exc:`SystemError` is set."
msgstr ""
"接受一个不变的Python对象(除了它的引用计数，引用计数会递增1)。如果传入的对象是一个 *NULL* "
"指针，会假设这是因为调用传递了错误的参数并且抛出异常。因此 :c:func:`Py_BuildValue` 会返回 *NULL* "
"但是不会引发异常。如果没有引发异常，:exc:`SystemError` 会被设置。"

#: ../../c-api/arg.rst:629
msgid "``S`` (object) [PyObject \\*]"
msgstr "``S`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:629
msgid "Same as ``O``."
msgstr "和``O``相同。"

#: ../../c-api/arg.rst:634
msgid "``N`` (object) [PyObject \\*]"
msgstr "``N`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:632
msgid ""
"Same as ``O``, except it doesn't increment the reference count on the "
"object. Useful when the object is created by a call to an object constructor"
" in the argument list."
msgstr "和``O``相同，然而它并不增加对象的引用计数。当通过调用参数列表中的对象构造器创建对象时很实用。"

#: ../../c-api/arg.rst:637
msgid ""
"Convert *anything* to a Python object through a *converter* function.  The "
"function is called with *anything* (which should be compatible with "
":c:type:`void \\*`) as its argument and should return a \"new\" Python "
"object, or *NULL* if an error occurred."
msgstr ""
"通过 *converter* 函数将 *任何类型的变量*转化为一个Python对象。这个函数调用 *任何类型的变量* (这个类型可以被 "
":c:type:`void \\*` 兼容) 作为它的参数，并且应该返回一个\"新的\"Python对象，或者 *NULL* 如果有错误产生。"

#: ../../c-api/arg.rst:643
msgid ""
"Convert a sequence of C values to a Python tuple with the same number of "
"items."
msgstr "将一个C变量序列转换成Python元组并保持相同的元素数量"

#: ../../c-api/arg.rst:646
msgid "``[items]`` (:class:`list`) [*matching-items*]"
msgstr "``[items]`` (:class:`list`) [*相关的元素*]"

#: ../../c-api/arg.rst:646
msgid ""
"Convert a sequence of C values to a Python list with the same number of "
"items."
msgstr "将一个C变量序列转换成Python列表并保持相同的元素数量"

#: ../../c-api/arg.rst:651
msgid "``{items}`` (:class:`dict`) [*matching-items*]"
msgstr "``{items}`` (:class:`dict`) [*相关的元素*]"

#: ../../c-api/arg.rst:649
msgid ""
"Convert a sequence of C values to a Python dictionary.  Each pair of "
"consecutive C values adds one item to the dictionary, serving as key and "
"value, respectively."
msgstr "将一个C变量序列转换成Python字典。每一对连续的C变量对作为一个元素插入字典中，分别作为关键字和值。"

#: ../../c-api/arg.rst:653
msgid ""
"If there is an error in the format string, the :exc:`SystemError` exception "
"is set and *NULL* returned."
msgstr "如果格式化字符串中有一个错误，异常 :exc:`SystemError` 会被设置并且返回 *NULL* 。"

#: ../../c-api/arg.rst:658
msgid ""
"Identical to :c:func:`Py_BuildValue`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr "和 :c:func:`Py_BuildValue` 相同，然而它接受一个va_list类型的参数而不是可变数量的参数集。"
