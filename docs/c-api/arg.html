
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>语句解释及变量编译 &#8212; Python 3.6.4 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.6.4 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权信息" href="../copyright.html" />
    <link rel="next" title="String conversion and formatting" href="conversion.html" />
    <link rel="prev" title="Data marshalling support" href="marshal.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/arg.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    
    
 

  </head>
  <body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="全文档索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="String conversion and formatting"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="Data marshalling support"
             accesskey="P">上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">3.6.4 Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API Reference Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" accesskey="U">Utilities</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="立即搜索" type="text" name="q" />
          <input type="submit" value="查找" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="parsing-arguments-and-building-values">
<span id="arg-parsing"></span><h1>语句解释及变量编译<a class="headerlink" href="#parsing-arguments-and-building-values" title="永久链接至标题">¶</a></h1>
<p>这些函数在创建你自己的函数时帮助很大。更多说明以及实例可参考说明文档中的 <a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">Extending and Embedding the Python Interpreter</span></a> 小节。</p>
<p>这些函数描述的前三个，<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a>，<a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>，以及 <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal"><span class="pre">PyArg_Parse()</span></code></a>，它们都使用 <em>格式化字符串</em> 来将函数期待的参数告知函数。这些函数都使用相同语法规则的格式化字符串。</p>
<div class="section" id="parsing-arguments">
<h2>解析参数<a class="headerlink" href="#parsing-arguments" title="永久链接至标题">¶</a></h2>
<p>一个格式化字符串包含0或者更多的格式单元。一个格式单元用来描述一个Python对象；它通常是一个字符或者由括号括起来的格式单元序列。除了少数例外，一个非括号序列的格式单元通常对应这些函数的具有单一地址的参数。在接下来的描述中，双引号内的表达式是格式单元；圆括号()内的是对应这个格式单元的Python对象类型；方括号[]内的是传递的C变量(变量集)类型。</p>
<div class="section" id="strings-and-buffers">
<h3>字符串和缓存区<a class="headerlink" href="#strings-and-buffers" title="永久链接至标题">¶</a></h3>
<p>这些格式允许将对象按照连续的内存块形式进行访问。你没必要提供返回的unicode字符或者字节区的原始数据存储。</p>
<p>一般的，当一个表达式设置一个指针指向一个缓冲区，这个缓冲区可以被相应的Python对象管理，并且这个缓冲区共享这个对象的生存周期。你不需要人为的释放任何内存空间。除了这些 <code class="docutils literal"><span class="pre">es</span></code>, <code class="docutils literal"><span class="pre">es#</span></code>, <code class="docutils literal"><span class="pre">et</span></code> and <code class="docutils literal"><span class="pre">et#</span></code>.</p>
<p>然而，当一个 <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal"><span class="pre">Py_buffer</span></code></a> 结构被赋值，其包含的缓冲区被锁住，所以调用者在随后使用这个缓冲区，即使在 <a class="reference internal" href="init.html#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-type docutils literal"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 块中，可以避免可变数据因为调整大小或者被销毁所带来的风险。因此，<strong>你不得不调用</strong> <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></code></a> 在你结束数据的处理时(或者在之前任何中断事件中)</p>
<p>除非另有说明，缓冲区是不会以空终止的。</p>
<p>有些格式要求一个只读的 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>，并且设置一个指针以取代一个缓存区结构。它们通过检查对象的 <a class="reference internal" href="typeobj.html#c.PyBufferProcs.bf_releasebuffer" title="PyBufferProcs.bf_releasebuffer"><code class="xref c c-member docutils literal"><span class="pre">PyBufferProcs.bf_releasebuffer</span></code></a> 字段是 <em>NULL</em> 来工作，它们不允许诸如 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 这种可变的对象。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">所有 <code class="docutils literal"><span class="pre">#</span></code> 表达式的变式(<code class="docutils literal"><span class="pre">s#</span></code>，<code class="docutils literal"><span class="pre">y#</span></code>，等等)，长度参数的类型(整型或者 <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code>)在包含 <code class="file docutils literal"><span class="pre">Python.h</span></code> 头文件之前由 <code class="xref c c-macro docutils literal"><span class="pre">PY_SSIZE_T_CLEAN</span></code> 宏的定义控制。如果这个宏被定义，长度是一个 <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> Python元大小类型而不是一个 <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 整型。在未来的Python版本中将会改变，只支持 <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> 而放弃支持 <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 整型。最好一直定义 <code class="xref c c-macro docutils literal"><span class="pre">PY_SSIZE_T_CLEAN</span></code> 这个宏。</p>
</div>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">s</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) [const char *]</dt>
<dd><p class="first">将一个Unicode对象转换成一个指向字符串的C指针。一个指针指向一个已经存在的字符串，这个字符串存储的是传如的字符指针变量。C字符串是已空结束的。Python字符串不能包含嵌入的无效的代码点；如果由，一个 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 异常会被引发。Unicode对象被转化成 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 编码的C字符串。如果转换失败，一个 <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> 异常被引发。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">这个表达式不接受 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>。如果你想接受文件系统路径并将它们转化成C字符串，建议使用 <code class="docutils literal"><span class="pre">O&amp;</span></code> 表达式配合 <a class="reference internal" href="unicode.html#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><code class="xref c c-func docutils literal"><span class="pre">PyUnicode_FSConverter()</span></code></a> 作为 <em>转化函数</em>。</p>
</div>
<div class="last versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>以前，当Python字符串中遇到了嵌入的null代码点会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 。</p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">s*</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> or <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [Py_buffer]</dt>
<dd>这个表达式既接受Unicode对象也接受类字节类型对象。它为由调用者提供的 <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal"><span class="pre">Py_buffer</span></code></a> 结构赋值。这里结果的C字符串可能包含嵌入的NUL字节。Unicode对象通过 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 编码转化成C字符串。</dd>
<dt><code class="docutils literal"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, 只读 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [const char *, int or <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code>]</dt>
<dd>像 <code class="docutils literal"><span class="pre">s*</span></code>，除了它不接受易变的对象。结果存储在两个C 变量中，第一个是指向C字符串的指针，第二个是它的长度。字符串可能包含嵌入的null字节。Unicode对象都被通过 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 编码转化成C字符串。</dd>
<dt><code class="docutils literal"><span class="pre">z</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> or <code class="docutils literal"><span class="pre">None</span></code>) [const char *]</dt>
<dd>像 <code class="docutils literal"><span class="pre">s</span></code>，但是这个Python对象也有可能是 <code class="docutils literal"><span class="pre">None</span></code>，那么对应的C指针指向 <em>NULL</em>。</dd>
<dt><code class="docutils literal"><span class="pre">z*</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or <code class="docutils literal"><span class="pre">None</span></code>) [Py_buffer]</dt>
<dd>像 <code class="docutils literal"><span class="pre">s*</span></code>，但是这个Python对象也有可能是 <code class="docutils literal"><span class="pre">None</span></code>，那么对应的 <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal"><span class="pre">Py_buffer</span></code></a> 结构中的 <code class="docutils literal"><span class="pre">buf</span></code> 指向 <em>NULL</em>。</dd>
<dt><code class="docutils literal"><span class="pre">z#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, 只读 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or <code class="docutils literal"><span class="pre">None</span></code>) [const char *, int]</dt>
<dd>像 <code class="docutils literal"><span class="pre">s#</span></code>，但是这个Python对象也有可能是 <code class="docutils literal"><span class="pre">None</span></code>，那么对应的C指针指向 <em>NULL</em>。</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code> (read-only <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [const char *]</dt>
<dd><p class="first">这个表达式将一个类字节类型对象转化成一个指向字符串的C指针；它不接受Unicode对象。字节缓存区必须不包含嵌入的null字节；如果包含了null字节，会引发一个 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 异常。</p>
<div class="last versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>以前，当字节缓冲区中遇到了嵌入的null字节会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 。</p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">y*</span></code> (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [Py_buffer]</dt>
<dd><code class="docutils literal"><span class="pre">s*</span></code> 的变式，不接受Unicode对象，只接受类字节类型变量。<strong>这是接受二进制数据的推荐方法</strong>。</dd>
<dt><code class="docutils literal"><span class="pre">y#</span></code> (read-only <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [const char *, int]</dt>
<dd>This variant on <code class="docutils literal"><span class="pre">s#</span></code> doesn’t accept Unicode objects, only bytes-like
objects.</dd>
<dt><code class="docutils literal"><span class="pre">S</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>) [PyBytesObject *]</dt>
<dd>要求Python对象是一个 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 类型对象，没有尝试任何的转换。如果不是一个字节类型对象会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 异常。C变量也可能声明为 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> 类型。</dd>
<dt><code class="docutils literal"><span class="pre">Y</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) [PyByteArrayObject *]</dt>
<dd>要求Python对象是一个 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 类型对象，没有尝试任何的转换。如果不是一个 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 类型对象会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 异常。C变量也可能声明为 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> 类型。</dd>
<dt><code class="docutils literal"><span class="pre">u</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) [Py_UNICODE *]</dt>
<dd><p class="first">将一个Python Unicode对象转化成指向一个以空终止的Unicode字符缓冲区的指针。你必须传入一个 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></code></a> 指针变量的地址，存储了一个指向已经存在的Unicode缓冲区的指针。请注意一个 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></code></a> 类型的字符宽度取决于编译选项(16位或者32位)。Python字符串必须不能包含嵌入的null代码点；如果有，引发一个 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 异常。</p>
<div class="last versionchanged">
<p><span class="versionmodified">在 3.5 版更改: </span>以前，当Python字符串中遇到了嵌入的null代码点会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 。</p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">u#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) [Py_UNICODE *, int]</dt>
<dd><code class="docutils literal"><span class="pre">u</span></code> 的变式，存储两个C变量，第一个指针指向一个Unicode数据缓存区，第二个是它的长度。它允许null代码点。</dd>
<dt><code class="docutils literal"><span class="pre">Z</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> or <code class="docutils literal"><span class="pre">None</span></code>) [Py_UNICODE *]</dt>
<dd>像 <code class="docutils literal"><span class="pre">u</span></code>，但是这个Python对象也有可能是 <code class="docutils literal"><span class="pre">None</span></code>，那么对应的 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></code></a> 指针指向 <em>NULL</em>。</dd>
<dt><code class="docutils literal"><span class="pre">Z#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> or <code class="docutils literal"><span class="pre">None</span></code>) [Py_UNICODE *, int]</dt>
<dd>像 <code class="docutils literal"><span class="pre">u#</span></code>，但是这个Python对象也有可能是 <code class="docutils literal"><span class="pre">None</span></code>，那么对应的 <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></code></a> 指针指向 <em>NULL</em>。</dd>
<dt><code class="docutils literal"><span class="pre">U</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) [PyObject *]</dt>
<dd>要求Python对象是一个Unicode对象，没有尝试任何的转换。如果不是一个Unicode对象会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 异常。C变量也可能声明为 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> 类型。</dd>
<dt><code class="docutils literal"><span class="pre">w*</span></code> (可读写 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>) [Py_buffer]</dt>
<dd>这个表达式接受任何实现可读写缓存区接口的对象。它为调用者提供的 <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><code class="xref c c-type docutils literal"><span class="pre">Py_buffer</span></code></a> 结构赋值。缓冲区可能存在嵌入的null字节。当缓冲区使用完后调用者需要调用 <a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></code></a>。</dd>
<dt><code class="docutils literal"><span class="pre">es</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) [const char *encoding, char **buffer]</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">s</span></code> 的变式，它将编码后的Unicode字符存入字符缓冲区。它只处理没有嵌入NUL字节的已编码数据</p>
<p>这个表达式需要两个参数。第一个仅用于传入，并且必须是一个 <code class="xref c c-type docutils literal"><span class="pre">const</span> <span class="pre">char*</span></code> 指向一个 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 编码的以空终止或者 <em>NULL</em> 的字符串名称。如果Python不识别名字的编码方式会引发一个异常。第二个参数必须是一个 <code class="xref c c-type docutils literal"><span class="pre">char**</span></code>；指针指向一个包含了参数文本内容的缓存区。文本将被第一个参数指定的编码格式编码。</p>
<p class="last"><a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> 会分配一个足够大小的缓冲区，将编码后的数据拷贝进这个缓冲区并且设置 <em>*buffer</em> 引用这个新分配的内存空间。调用者有责任在使用后调用 <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></code></a> 去释放已经分配的缓冲区。</p>
</dd>
<dt><code class="docutils literal"><span class="pre">et</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> or <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) [const char *encoding, char **buffer]</dt>
<dd>和 <code class="docutils literal"><span class="pre">es</span></code> 相同，除了不用重编码传入的字符串对象。相反，它假设传入的参数是编码后的字符串类型。</dd>
<dt><code class="docutils literal"><span class="pre">es#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) [const char *encoding, char **buffer, int *buffer_length]</dt>
<dd><p class="first"><code class="docutils literal"><span class="pre">s#</span></code> 的变式，它将已编码的Unicode字符存入字符缓冲区。不像 <code class="docutils literal"><span class="pre">es</span></code> 表达式，它允许传入的数据包含NUL字符。</p>
<p>它需要三个参数。第一个仅用于传入，并且必须是一个 <code class="xref c c-type docutils literal"><span class="pre">const</span> <span class="pre">char*</span></code> 指向一个 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 编码的以空终止或者 <em>NULL</em> 的字符串名称。如果Python不识别名字的编码方式会引发一个异常。第二个参数必须是一个 <code class="xref c c-type docutils literal"><span class="pre">char**</span></code>；指针指向一个包含了参数文本内容的缓存区。文本将被第一个参数指定的编码格式编码。第三个参数必须是一个整型指针；指针引用的值用来设定输出缓冲区的字节数量。</p>
<p>有两种操作方式：</p>
<p>如果 <em>*buffer</em> 指向 <em>NULL</em>，这个函数会分配一个足够大小的缓冲区，将编码后的数据拷贝进这个缓冲区并且设置 <em>*buffer</em> 引用这个新分配的内存空间。调用者有责任在使用后调用 <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></code></a> 去释放已经分配的缓冲区。</p>
<p>If <em>*buffer</em> points to a non-<em>NULL</em> pointer (an already allocated buffer),
<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> will use this location as the buffer and interpret the
initial value of <em>*buffer_length</em> as the buffer size.  It will then copy the
encoded data into the buffer and NUL-terminate it.  If the buffer is not large
enough, a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> will be set.</p>
<p class="last">在这两个例子中，<em>*buffer_length</em> 被设置为编码后结尾不为NUL的数据的长度。</p>
</dd>
<dt><code class="docutils literal"><span class="pre">et#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> or <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a>) [const char *encoding, char **buffer, int *buffer_length]</dt>
<dd>和 <code class="docutils literal"><span class="pre">es#</span></code> 相同，除了不用重编码传入的字符串对象。相反，它假设传入的参数是编码后的字符串类型。</dd>
</dl>
</div>
<div class="section" id="numbers">
<h3>数字<a class="headerlink" href="#numbers" title="永久链接至标题">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">b</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned char]</dt>
<dd>将一个非负的Python整型转化成一个无符号的微整型，存储在一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></code> 类型中。</dd>
<dt><code class="docutils literal"><span class="pre">B</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned char]</dt>
<dd>将一个Python整型转化成一个微整型并不检查溢出问题，存储在一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></code> 类型中。</dd>
<dt><code class="docutils literal"><span class="pre">h</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [short int]</dt>
<dd>将一个Python整型转化成一个C <code class="xref c c-type docutils literal"><span class="pre">short</span> <span class="pre">int</span></code> 短整型。</dd>
<dt><code class="docutils literal"><span class="pre">H</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned short int]</dt>
<dd>将一个Python整型转化成一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">int</span></code> 无符号短整型，并不检查溢出问题。</dd>
<dt><code class="docutils literal"><span class="pre">i</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [int]</dt>
<dd>将一个Python整型转化成一个C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 整型。</dd>
<dt><code class="docutils literal"><span class="pre">I</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned int]</dt>
<dd>将一个Python整型转化成一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code> 无符号整型，并不检查溢出问题。</dd>
<dt><code class="docutils literal"><span class="pre">l</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [long int]</dt>
<dd>将一个Python整型转化成一个C <code class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">int</span></code> 长整型。</dd>
<dt><code class="docutils literal"><span class="pre">k</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned long]</dt>
<dd>将一个Python整型转化成一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">int</span></code> 无符号长整型，并不检查溢出问题。</dd>
<dt><code class="docutils literal"><span class="pre">L</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [long long]</dt>
<dd>Convert a Python integer to a C <code class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">K</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned long long]</dt>
<dd>Convert a Python integer to a C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>
without overflow checking.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [Py_ssize_t]</dt>
<dd>将一个Python整型转化成一个C <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> Python元大小类型。</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 或者 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 长度为1) [char]</dt>
<dd><p class="first">将一个Python字节类型，如一个长度为1的 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 或者 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 对象，转化成一个C <code class="xref c c-type docutils literal"><span class="pre">char</span></code> 字符类型。</p>
<div class="last versionchanged">
<p><span class="versionmodified">在 3.3 版更改: </span>允许 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal"><span class="pre">bytearray</span></code></a> 类型的对象。</p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">C</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 长度为1) [int]</dt>
<dd>将一个Python字符，如一个长度为1的 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 字符串对象，转化成一个C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 整型类型。</dd>
<dt><code class="docutils literal"><span class="pre">f</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) [float]</dt>
<dd>将一个Python浮点数转化成一个C <code class="xref c c-type docutils literal"><span class="pre">float</span></code> 浮点数。</dd>
<dt><code class="docutils literal"><span class="pre">d</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) [double]</dt>
<dd>将一个Python浮点数转化成一个C <code class="xref c c-type docutils literal"><span class="pre">double</span></code> 双精度浮点数。</dd>
<dt><code class="docutils literal"><span class="pre">D</span></code> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a>) [Py_complex]</dt>
<dd>将一个Python复数类型转化成一个C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal"><span class="pre">Py_complex</span></code></a> Python复数类型。</dd>
</dl>
</div>
<div class="section" id="other-objects">
<h3>其他对象<a class="headerlink" href="#other-objects" title="永久链接至标题">¶</a></h3>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">O</span></code> (object) [PyObject *]</dt>
<dd>用一个C的对象指针存储一个Python对象(没有任何格式转换)。这样传递给C程序的是实际的对象。这个对象的引用计数不会增加。这个指针存储的不是 <em>NULL</em>。</dd>
<dt><code class="docutils literal"><span class="pre">O!</span></code> (object) [<em>typeobject</em>, PyObject *]</dt>
<dd>将一个Python对象存入一个C指针。和 <code class="docutils literal"><span class="pre">O</span></code> 类似，但是需要两个C参数：第一个是Python类型对象的地址，第二个是存储对象指针的C变量( <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> 变量)的地址。如果Python对象类型不对，会抛出 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 异常。</dd>
</dl>
<dl class="docutils" id="o-ampersand">
<dt><code class="docutils literal"><span class="pre">O&amp;</span></code> (object) [<em>converter</em>, <em>anything</em>]</dt>
<dd><p class="first">通过一个 <em>converter</em> 函数将一个Python对象转换成一个C变量。这需要两个参数：第一个是一个函数，第二个是一个C变量的地址(任意类型的)，转化为 <code class="xref c c-type docutils literal"><span class="pre">void</span> <span class="pre">*</span></code> 类型。<em>converter</em> 函数像这样被调用：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">status</span> <span class="o">=</span> <span class="n">converter</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
</pre></div>
</div>
<p><em>object*是待转化的Python对象并且 *address</em> 是传入 <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal"><span class="pre">PyArg_Parse*()</span></code></a> 函数的 <code class="xref c c-type docutils literal"><span class="pre">void*</span></code> 类型参数。返回的 <em>status</em> 是1代表转换成功，0代表转换失败。当转换失败，<em>converter*函数会引发一个异常并且不会修改 *address</em> 的内容。</p>
<p>如果 <em>converter</em> 返回 <code class="docutils literal"><span class="pre">Py_CLEANUP_SUPPORTED</span></code>，如果参数解析最后失败了它会被第二次调用，给转换函数一个机会区释放它已经分配的内存。在第二次调用中， <em>object</em> 参数会是NULL； <em>address</em> 会保持第一次调用时的值。</p>
<div class="last versionchanged">
<p><span class="versionmodified">在 3.1 版更改: </span><code class="docutils literal"><span class="pre">Py_CLEANUP_SUPPORTED</span></code> 被添加。</p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">p</span></code> (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal"><span class="pre">bool</span></code></a>) [int]</dt>
<dd><p class="first">Tests the value passed in for truth (a boolean <strong>p</strong>redicate) and converts
the result to its equivalent C true/false integer value.
Sets the int to <code class="docutils literal"><span class="pre">1</span></code> if the expression was true and <code class="docutils literal"><span class="pre">0</span></code> if it was false.
This accepts any valid Python value.  See <a class="reference internal" href="../library/stdtypes.html#truth"><span class="std std-ref">Truth Value Testing</span></a> for more
information about how Python tests values for truth.</p>
<div class="last versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">(items)</span></code> (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>) [<em>matching-items</em>]</dt>
<dd>对象必须是Python序列，它的长度是 <em>items</em> 中格式单元的数量。C参数必须对应 <em>items</em> 中每一个独立的格式单元。序列中的格式单元可能有嵌套。</dd>
</dl>
<p>传递 “长”整型(整型的值超过了平台的 <code class="xref py py-const docutils literal"><span class="pre">LONG_MAX</span></code> 限制)是可能的，然而没有进行适当的范围检测——当接收字段太小而接收不到值时，最重要的位被静默地截断(实际上，C语言会在语义继承的基础上强制类型转换——期望的值可能会发生变化)。</p>
<p>格式化字符串中还有一些其他的字符具有特殊的涵义。这些可能并不嵌套在圆括号中。它们是：</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">|</span></code></dt>
<dd>表明在Python参数列表中剩下的参数都是可选的。C变量对应的可选参数需要初始化为默认值——当一个可选参数没有指定时， <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a>  不能访问相应的C变量(变量集)的内容。</dd>
<dt><code class="docutils literal"><span class="pre">$</span></code></dt>
<dd><p class="first"><a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> only：表明在Python参数列表中剩下的参数都是强制关键字参数。当前，所有强制关键字参数都必须也是可选参数，所以格式化字符串中  <code class="docutils literal"><span class="pre">|</span></code> 必须一直在 <code class="docutils literal"><span class="pre">$</span></code> 前面。</p>
<div class="last versionadded">
<p><span class="versionmodified">3.3 新版功能.</span></p>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">:</span></code></dt>
<dd>格式单元的列表结束标志；冒号后的字符串被用来作为错误消息中的函数名(<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> 函数引发的“关联值”异常)。</dd>
<dt><code class="docutils literal"><span class="pre">;</span></code></dt>
<dd>格式单元的列表结束标志；分号后的字符串被用来作为错误消息取代默认的错误消息。 <code class="docutils literal"><span class="pre">:</span></code> 和 <code class="docutils literal"><span class="pre">;</span></code> 相互排斥。</dd>
</dl>
<p>注意任何由调用者提供的Python对象引用是 <em>借来的</em> 引用；不要递减它们的引用计数！</p>
<p>传递给这些函数的附加参数必须是由格式化字符串确定的变量的地址；这些都是用来存储输入元组的值。有一些情况，如上面的格式单元列表中所描述的，这些参数作为输入值使用；在这种情况下，它们应该匹配指定的相应的格式单元。</p>
<p>为了转换成功，<em>arg</em> 对象必须匹配格式并且格式必须用尽。成功的话，<a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal"><span class="pre">PyArg_Parse*()</span></code></a> 函数返回true，反之它们返回false并且引发一个合适的异常。当 <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal"><span class="pre">PyArg_Parse*()</span></code></a> 函数因为某一个格式单元转化失败而失败时，对应的以及后续的格式单元地址内的变量都不会被使用。</p>
</div>
<div class="section" id="api-functions">
<h3>API 函数<a class="headerlink" href="#api-functions" title="永久链接至标题">¶</a></h3>
<dl class="function">
<dt id="c.PyArg_ParseTuple">
int <code class="descname">PyArg_ParseTuple</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, const char<em>&nbsp;*format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ParseTuple" title="永久链接至目标">¶</a></dt>
<dd><p>解析一个函数的参数，表达式中的参数按参数位置顺序存入局部变量中。成功返回true；失败返回false并且引发相应的异常。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_VaParse">
int <code class="descname">PyArg_VaParse</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, const char<em>&nbsp;*format</em>, va_list<em>&nbsp;vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_VaParse" title="永久链接至目标">¶</a></dt>
<dd><p>和 <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> 相同，然而它接受一个va_list类型的参数而不是可变数量的参数集。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_ParseTupleAndKeywords">
int <code class="descname">PyArg_ParseTupleAndKeywords</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kw</em>, const char<em>&nbsp;*format</em>, char<em>&nbsp;*keywords[]</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ParseTupleAndKeywords" title="永久链接至目标">¶</a></dt>
<dd><p>Parse the parameters of a function that takes both positional and keyword
parameters into local variables.  The <em>keywords</em> argument is a
<em>NULL</em>-terminated array of keyword parameter names.  Empty names denote
<a class="reference internal" href="../glossary.html#positional-only-parameter"><span class="std std-ref">positional-only parameters</span></a>.
Returns true on success; on failure, it returns false and raises the
appropriate exception.</p>
<div class="versionchanged">
<p><span class="versionmodified">在 3.6 版更改: </span>Added support for <a class="reference internal" href="../glossary.html#positional-only-parameter"><span class="std std-ref">positional-only parameters</span></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_VaParseTupleAndKeywords">
int <code class="descname">PyArg_VaParseTupleAndKeywords</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kw</em>, const char<em>&nbsp;*format</em>, char<em>&nbsp;*keywords[]</em>, va_list<em>&nbsp;vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_VaParseTupleAndKeywords" title="永久链接至目标">¶</a></dt>
<dd><p>和 <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 相同，然而它接受一个va_list类型的参数而不是可变数量的参数集。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_ValidateKeywordArguments">
int <code class="descname">PyArg_ValidateKeywordArguments</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ValidateKeywordArguments" title="永久链接至目标">¶</a></dt>
<dd><p>确保字典中的关键字参数都是字符串。这个函数只被使用于 <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 不被使用的情况下，后者已经不再做这样的检查。</p>
<div class="versionadded">
<p><span class="versionmodified">3.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_Parse">
int <code class="descname">PyArg_Parse</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, const char<em>&nbsp;*format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_Parse" title="永久链接至目标">¶</a></dt>
<dd><p>函数被用来析构“旧类型”函数的参数列表——这些函数使用的 <code class="xref py py-const docutils literal"><span class="pre">METH_OLDARGS</span></code> 参数解析方法已从Python 3中移除。这不被推荐用于新代码的参数解析，并且在标准解释器中的大多数代码已被修改，已不再用于该目的。它仍然方便于分解其他元组，然而可能因为这个目的被继续使用。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_UnpackTuple">
int <code class="descname">PyArg_UnpackTuple</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, const char<em>&nbsp;*name</em>, Py_ssize_t<em>&nbsp;min</em>, Py_ssize_t<em>&nbsp;max</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_UnpackTuple" title="永久链接至目标">¶</a></dt>
<dd><p>一个不使用格式化字符串指定参数类型的简单形式的参数检索。使用这种方法来检索参数的函数应该在函数或者方法表中声明 <a class="reference internal" href="structures.html#METH_VARARGS" title="METH_VARARGS"><code class="xref py py-const docutils literal"><span class="pre">METH_VARARGS</span></code></a>。包含实际参数的元组应该以 <em>args</em> 形式被传入；它必须是一个实际的元组。元组的长度必须至少是 <em>min</em> 并且不超过 <em>max</em>； <em>min</em> 和 <em>max</em> 可能相同。额外的参数必须传递给函数，每一个参数必须是一个指向 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal"><span class="pre">PyObject*</span></code></a> 类型变量的指针；它们将被赋值为 <em>args</em> 的值；它们将包含借来的引用。不在 <em>args</em> 里面的可选参数不会被赋值；由调用者完成初始化。函数成功则返回true并且如果 <em>args</em> 不是元组或者包含错误数量的元素则返回false；如果失败了会引发一个异常。</p>
<p>这是一个使用此函数的示例，取自 <code class="xref py py-mod docutils literal"><span class="pre">_weakref</span></code> 帮助模块用来弱化引用的源代码：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">weakref_ref</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;ref&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">PyWeakref_NewRef</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个例子中调用 <a class="reference internal" href="#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_UnpackTuple()</span></code></a> 完全等价于调用 <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;O|O:ref&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="building-values">
<h2>创建变量<a class="headerlink" href="#building-values" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt id="c.Py_BuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">Py_BuildValue</code><span class="sig-paren">(</span>const char<em>&nbsp;*format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BuildValue" title="永久链接至目标">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>基于格式化字符串创建一个新的值和那些 <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal"><span class="pre">PyArg_Parse*()</span></code></a> 函数族接受的函数及一系列值类似。返回这个值或者一旦出错返回 <em>NULL</em>；如果返回的是 <em>NULL</em> 会引发一个异常。</p>
<p><a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></code></a> 并不一直创建一个元组。只有当它的格式化字符串包含两个或更多的格式单元才会创建一个元组。如果格式化字符串是空，它返回 <code class="docutils literal"><span class="pre">None</span></code>；如果它包含一个格式单元，它返回由格式单元描述的的任一对象。用圆括号包裹格式化字符串可以强制它返回一个大小为0或者1的元组</p>
<p>当内存缓存区的数据以参数形式传递用来构建对象时，如 <code class="docutils literal"><span class="pre">s</span></code> 和 <code class="docutils literal"><span class="pre">s#</span></code> 格式单元，会拷贝需要的数据。调用者提供的缓冲区从来都不会被由 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></code></a> 创建的对象来引用。换句话说，如果你的代码调用 <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> 并且将分配的内存空间传递给 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></code></a>，你的代码就有责任在 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></code></a> 返回时调用 <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> 。</p>
<p>在下面的描述中，双引号的表达式使格式单元；圆括号()内的是格式单元将要返回的Python对象类型；方括号[]内的是传递的C变量(变量集)的类型</p>
<p>字符例如空格，制表符，冒号和逗号在格式化字符串中会被忽略(但是不包括格式单元，如 <code class="docutils literal"><span class="pre">s#</span></code>)。这可以使很长的格式化字符串具有更好的可读性。</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 或者 <code class="docutils literal"><span class="pre">None</span></code>) [char *, int]</dt>
<dd>使用 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 编码将一个C以空结束的字符串转化成Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 字符串对象。如果这个C字符串指针是 <em>NULL</em> ，返回 <code class="docutils literal"><span class="pre">None</span></code> 。</dd>
<dt><code class="docutils literal"><span class="pre">s#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 或者 <code class="docutils literal"><span class="pre">None</span></code>) [char *, int]</dt>
<dd>使用 <code class="docutils literal"><span class="pre">'utf-8'</span></code> 编码将一个C字符串和其长度转化成Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 字符串对象。如果这个C字符串指针是 <em>NULL</em> ，长度会被忽略并且返回 <code class="docutils literal"><span class="pre">None</span></code> 。</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>) [char *]</dt>
<dd>它将一个C字符串和其长度转化成一个Python <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 字节类型对象。如果这个C字符串指针是 <em>NULL</em>，返回``None``</dd>
<dt><code class="docutils literal"><span class="pre">y#</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>) [char *, int]</dt>
<dd>它将一个C字符串和其长度转化成一个Python对象。如果这个C字符串指针是 <em>NULL</em>，返回``None``。</dd>
<dt><code class="docutils literal"><span class="pre">z</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 或者 <code class="docutils literal"><span class="pre">None</span></code>) [char *]</dt>
<dd>和``s``一样。</dd>
<dt><code class="docutils literal"><span class="pre">z#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 或者 <code class="docutils literal"><span class="pre">None</span></code>) [char *, int]</dt>
<dd>和``s#``一样。</dd>
<dt><code class="docutils literal"><span class="pre">u</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) [Py_UNICODE *]</dt>
<dd>将一个以空结束的Unicode(UCS-2或者UCS-4)数据缓存区转化成Python Unicode对象。如果这个Unicode缓存区指针是 <em>NULL</em>，返回``None``</dd>
<dt><code class="docutils literal"><span class="pre">u#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>) [Py_UNICODE *, int]</dt>
<dd>将一个Unicode(UCS-2或者UCS-4)数据缓存区和它的长度转化成Python Unicode对象。如果这个Unicode缓存区指针是 <em>NULL</em>，长度将被忽略并且返回``None``</dd>
<dt><code class="docutils literal"><span class="pre">U</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 或者 <code class="docutils literal"><span class="pre">None</span></code>) [char *]</dt>
<dd>和``s``一样。</dd>
<dt><code class="docutils literal"><span class="pre">U#</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 或者 <code class="docutils literal"><span class="pre">None</span></code>) [char *, int]</dt>
<dd>和``s#``一样。</dd>
<dt><code class="docutils literal"><span class="pre">i</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [int]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 整型转化成Python整型对象。</dd>
<dt><code class="docutils literal"><span class="pre">b</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [char]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">char</span></code> 字符型转化成Python整型对象。</dd>
<dt><code class="docutils literal"><span class="pre">h</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [short int]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">short</span> <span class="pre">int</span></code> 短整型转化成Python整型对象。</dd>
<dt><code class="docutils literal"><span class="pre">l</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [long int]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">int</span></code> 长整型转化成Python整型对象。</dd>
<dt><code class="docutils literal"><span class="pre">B</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned char]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></code> 无符号字符型转化成Python整型对象。</dd>
<dt><code class="docutils literal"><span class="pre">H</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned short int]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></code> 无符号短整型转化成Python整型对象。</dd>
<dt><code class="docutils literal"><span class="pre">I</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned int]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></code> 无符号整型转化成Python整型对象。</dd>
<dt><code class="docutils literal"><span class="pre">k</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned long]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></code> 无符号长整型转化成Python整型对象。</dd>
<dt><code class="docutils literal"><span class="pre">L</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [long long]</dt>
<dd>Convert a C <code class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></code> to a Python integer object.</dd>
<dt><code class="docutils literal"><span class="pre">K</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [unsigned long long]</dt>
<dd>Convert a C <code class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> to a Python integer object.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code> (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a>) [Py_ssize_t]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></code> 类型转化为Python整型。</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code> (<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 长度为1 ) [char]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 整型代表的字符转化为Python <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> 长度为1的字节对象。</dd>
<dt><code class="docutils literal"><span class="pre">C</span></code> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 长度为1) [int]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">int</span></code> 整型代表的字符转化为Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> 长度为1的字符串对象。</dd>
<dt><code class="docutils literal"><span class="pre">d</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) [double]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">double</span></code> 双精度浮点数转化为Python浮点数类型数字。</dd>
<dt><code class="docutils literal"><span class="pre">f</span></code> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal"><span class="pre">float</span></code></a>) [float]</dt>
<dd>将一个C <code class="xref c c-type docutils literal"><span class="pre">float</span></code> 单精度浮点数转化为Python浮点数类型数字。</dd>
<dt><code class="docutils literal"><span class="pre">D</span></code> (<code class="xref py py-class docutils literal"><span class="pre">复数</span></code>) [Py_complex *]</dt>
<dd>将一个C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal"><span class="pre">Py_complex</span></code></a> 类型的结构转化为Python复数类型。</dd>
<dt><code class="docutils literal"><span class="pre">O</span></code> (object) [PyObject *]</dt>
<dd>接受一个不变的Python对象(除了它的引用计数，引用计数会递增1)。如果传入的对象是一个 <em>NULL</em> 指针，会假设这是因为调用传递了错误的参数并且抛出异常。因此 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></code></a> 会返回 <em>NULL</em> 但是不会引发异常。如果没有引发异常，<a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal"><span class="pre">SystemError</span></code></a> 会被设置。</dd>
<dt><code class="docutils literal"><span class="pre">S</span></code> (object) [PyObject *]</dt>
<dd>和``O``相同。</dd>
<dt><code class="docutils literal"><span class="pre">N</span></code> (object) [PyObject *]</dt>
<dd>和``O``相同，然而它并不增加对象的引用计数。当通过调用参数列表中的对象构造器创建对象时很实用。</dd>
<dt><code class="docutils literal"><span class="pre">O&amp;</span></code> (object) [<em>converter</em>, <em>anything</em>]</dt>
<dd>通过 <em>converter</em> 函数将 <em>任何类型的变量*转化为一个Python对象。这个函数调用 *任何类型的变量</em> (这个类型可以被 <code class="xref c c-type docutils literal"><span class="pre">void</span> <span class="pre">*</span></code> 兼容) 作为它的参数，并且应该返回一个”新的”Python对象，或者 <em>NULL</em> 如果有错误产生。</dd>
<dt><code class="docutils literal"><span class="pre">(items)</span></code> (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a>) [<em>matching-items</em>]</dt>
<dd>将一个C变量序列转换成Python元组并保持相同的元素数量</dd>
<dt><code class="docutils literal"><span class="pre">[items]</span></code> (<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a>) [<em>相关的元素</em>]</dt>
<dd>将一个C变量序列转换成Python列表并保持相同的元素数量</dd>
<dt><code class="docutils literal"><span class="pre">{items}</span></code> (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a>) [<em>相关的元素</em>]</dt>
<dd>将一个C变量序列转换成Python字典。每一对连续的C变量对作为一个元素插入字典中，分别作为关键字和值。</dd>
</dl>
<p>如果格式化字符串中有一个错误，异常 <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><code class="xref py py-exc docutils literal"><span class="pre">SystemError</span></code></a> 会被设置并且返回 <em>NULL</em> 。</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_VaBuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">Py_VaBuildValue</code><span class="sig-paren">(</span>const char<em>&nbsp;*format</em>, va_list<em>&nbsp;vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_VaBuildValue" title="永久链接至目标">¶</a></dt>
<dd><p>和 <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></code></a> 相同，然而它接受一个va_list类型的参数而不是可变数量的参数集。</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">语句解释及变量编译</a><ul>
<li><a class="reference internal" href="#parsing-arguments">解析参数</a><ul>
<li><a class="reference internal" href="#strings-and-buffers">字符串和缓存区</a></li>
<li><a class="reference internal" href="#numbers">数字</a></li>
<li><a class="reference internal" href="#other-objects">其他对象</a></li>
<li><a class="reference internal" href="#api-functions">API 函数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-values">创建变量</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="marshal.html"
                        title="上一章">Data marshalling support</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="conversion.html"
                        title="下一章">String conversion and formatting</a></p>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/c-api/arg.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="全文档索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="String conversion and formatting"
             >下一页</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="Data marshalling support"
             >上一页</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">3.6.4 Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API Reference Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" >Utilities</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="立即搜索" type="text" name="q" />
          <input type="submit" value="查找" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权信息</a> 2001-2018, Python Software Foundation.
    <br />
    Python 软件基金会是一个非盈利组织。
    <a href="https://www.python.org/psf/donations/">请捐助。</a>
    <br />
    上次更新于 1月 15, 2018。
    <a href="../bugs.html">发现了问题</a>？
    <br />
    使用<a href="http://sphinx.pocoo.org/">Sphinx</a>1.6.6 创建。
    </div>

  </body>
</html>